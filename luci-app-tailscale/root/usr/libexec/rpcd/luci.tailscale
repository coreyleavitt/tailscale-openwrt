#!/bin/sh

. /usr/share/libubox/jshn.sh

KILLSWITCH_SCRIPT="/usr/sbin/tailscale-killswitch"
CACHE_FILE="/tmp/tailscale_status_cache.json"
VERBOSE_CACHE_FILE="/tmp/tailscale_status_verbose_cache.txt"
PREFS_CACHE_FILE="/tmp/tailscale_prefs_cache.json"
EXIT_NODES_CACHE_FILE="/tmp/tailscale_exit_nodes_cache.txt"
CACHE_TTL=5
EXIT_NODES_CACHE_TTL=60

# Security Notes
# - CSRF protection: Handled by LuCI/rpcd framework via session tokens
# - Input validation: All user inputs validated before shell command execution
# - ACL permissions: Read/write methods separated in acl.d/luci-app-tailscale.json
#
# Tailscale Version Requirements
# - Minimum tested version: Tailscale 1.30+
# - JSON format support for 'exit-node list --json': Tailscale 1.38+
# - If JSON format is not available, falls back to text parsing (fragile)
# - Text parsing depends on specific column format and may break with updates

# check_tailscale_version - Logs Tailscale version for compatibility tracking
# No args, no return value - only logs for informational purposes
check_tailscale_version() {
	local ts_version=$(/usr/bin/tailscale version 2>&1 | head -n1 | awk '{print $1}')
	if [ -n "$ts_version" ]; then
		logger -t tailscale-luci "Tailscale version: $ts_version"
		# Parse version and warn if very old (< 1.30)
		local major=$(echo "$ts_version" | cut -d'.' -f1)
		local minor=$(echo "$ts_version" | cut -d'.' -f2)
		if [ "$major" -eq 1 ] && [ "$minor" -lt 30 ]; then
			logger -t tailscale-luci "WARNING: Tailscale version $ts_version is older than minimum tested version 1.30"
		fi
	else
		logger -t tailscale-luci "WARNING: Could not detect Tailscale version"
	fi
}

# Input validation functions

# validate_node_format - Validates exit node format
# Args:
#   $1: node - Can be "hostname", "IP", "hostname (IP)", "none", or empty
# Returns:
#   0 if valid format, 1 if invalid
validate_node_format() {
	local node="$1"

	# Allow empty/none
	[ -z "$node" ] || [ "$node" = "none" ] && return 0

	# Check for "hostname (IP)" format
	if echo "$node" | grep -q '('; then
		# Extract hostname and IP parts
		local hostname=$(echo "$node" | sed 's/ *(.*//')
		local ip=$(echo "$node" | sed 's/.*(\([^)]*\)).*/\1/')

		# Two-stage hostname validation for better error messages
		# Stage 1: Quick character whitelist check
		if ! echo "$hostname" | grep -qE '^[a-zA-Z0-9.-]+$'; then
			logger -t tailscale-luci "Invalid characters in hostname: $hostname"
			return 1
		fi
		# Stage 2: RFC-compliant structure validation
		if ! echo "$hostname" | grep -qE '^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*$'; then
			logger -t tailscale-luci "Invalid hostname format: $hostname"
			return 1
		fi

		# Validate IP part
		echo "$ip" | grep -qE '^([0-9]{1,3}\.){3}[0-9]{1,3}$' || return 1

		# Check octets are <= 255
		local IFS='.'
		for octet in $ip; do
			# Verify octet is numeric
			case "$octet" in
				''|*[!0-9]*) return 1 ;;
			esac
			[ "$octet" -gt 255 ] && return 1
		done
		return 0
	fi

	# Just an IP address
	if echo "$node" | grep -qE '^[0-9.]+$'; then
		echo "$node" | grep -qE '^([0-9]{1,3}\.){3}[0-9]{1,3}$' || return 1
		local IFS='.'
		for octet in $node; do
			# Verify octet is numeric
			case "$octet" in
				''|*[!0-9]*) return 1 ;;
			esac
			[ "$octet" -gt 255 ] && return 1
		done
		return 0
	fi

	# Just a hostname - two-stage validation
	# Stage 1: Quick character whitelist check
	if ! echo "$node" | grep -qE '^[a-zA-Z0-9.-]+$'; then
		logger -t tailscale-luci "Invalid characters in hostname: $node"
		return 1
	fi
	# Stage 2: RFC-compliant structure validation
	if ! echo "$node" | grep -qE '^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*$'; then
		logger -t tailscale-luci "Invalid hostname format: $node"
		return 1
	fi
	return 0
}

# validate_cidr_list - Validates comma-separated list of CIDR blocks (IPv4 and IPv6)
# Args:
#   $1: routes - Comma-separated CIDR list (e.g., "192.168.1.0/24,2001:db8::/32")
# Returns:
#   0 if valid format, 1 if invalid
validate_cidr_list() {
	local routes="$1"
	[ -z "$routes" ] && return 0

	# Check for basic CIDR format characters (allow hex for IPv6)
	echo "$routes" | grep -qE '^[0-9a-fA-F.:/,]+$' || return 1

	# Validate each CIDR block
	local IFS=','
	for cidr in $routes; do
		local ip_part=$(echo "$cidr" | cut -d'/' -f1)
		local prefix=$(echo "$cidr" | cut -d'/' -f2)

		# Check if it's IPv6 (contains colon)
		if echo "$ip_part" | grep -q ':'; then
			# IPv6 validation: must have valid hex digits and colons only
			echo "$ip_part" | grep -qE '^[0-9a-fA-F:]+$' || return 1
			# Verify at least one colon and no invalid patterns
			echo "$ip_part" | grep -q ':' || return 1
			# Reject invalid patterns like ::: (more than two consecutive colons)
			echo "$ip_part" | grep -qE ':::' && return 1
			# Verify prefix is numeric
			case "$prefix" in
				''|*[!0-9]*) return 1 ;;
			esac
			[ "$prefix" -gt 128 ] && return 1
		else
			# IPv4 CIDR format: x.x.x.x/y where x is 0-255 and y is 0-32
			echo "$cidr" | grep -qE '^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$' || return 1
			# Verify prefix is numeric
			case "$prefix" in
				''|*[!0-9]*) return 1 ;;
			esac
			[ "$prefix" -gt 32 ] && return 1

			# Validate octets are 0-255
			local IFS='.'
			for octet in $ip_part; do
				# Verify octet is numeric
				case "$octet" in
					''|*[!0-9]*) return 1 ;;
				esac
				[ "$octet" -gt 255 ] && return 1
			done
		fi
	done

	return 0
}

# Portable file age calculation (BusyBox compatible)
# Args:
#   $1: file - Path to file
# Returns:
#   File age in seconds (999999 if file doesn't exist)
get_file_age() {
	local file="$1"
	[ ! -f "$file" ] && echo 999999 && return
	local now=$(date +%s)
	local mtime=$(date -r "$file" +%s 2>/dev/null || echo 0)
	echo $((now - mtime))
}

# get_cached_status - Returns cached tailscale status (5s TTL)
# Returns:
#   JSON output from 'tailscale status --json'
get_cached_status() {
	if [ -f "$CACHE_FILE" ]; then
		local cache_age=$(get_file_age "$CACHE_FILE")
		if [ "$cache_age" -lt "$CACHE_TTL" ]; then
			cat "$CACHE_FILE"
			return 0
		fi
	fi

	# Cache miss or expired - fetch new status
	local status=$(/usr/bin/tailscale status --json 2>&1)
	echo "$status" > "$CACHE_FILE"
	echo "$status"
	return 0
}

# invalidate_cache - Clears all cache files
# Used after configuration changes to ensure fresh data on next read
invalidate_cache() {
	rm -f "$CACHE_FILE"
	rm -f "$VERBOSE_CACHE_FILE"
	rm -f "$PREFS_CACHE_FILE"
	rm -f "$EXIT_NODES_CACHE_FILE"
}

# Get killswitch status with better parsing
get_killswitch_status() {
	local ks_output=$($KILLSWITCH_SCRIPT status 2>&1)
	local ks_state="unknown"

	# Parse status more robustly
	if echo "$ks_output" | grep -qi "enabled"; then
		ks_state="enabled"
	elif echo "$ks_output" | grep -qi "disabled"; then
		ks_state="disabled"
	elif echo "$ks_output" | grep -qi "not found\|not installed"; then
		ks_state="not_installed"
	elif echo "$ks_output" | grep -qi "error"; then
		ks_state="error"
	fi

	echo "$ks_state"
}

# Get cached verbose status
get_cached_verbose_status() {
	if [ -f "$VERBOSE_CACHE_FILE" ]; then
		local cache_age=$(get_file_age "$VERBOSE_CACHE_FILE")
		if [ "$cache_age" -lt "$CACHE_TTL" ]; then
			cat "$VERBOSE_CACHE_FILE"
			return 0
		fi
	fi

	# Cache miss or expired - fetch new verbose status
	local verbose_status=$($KILLSWITCH_SCRIPT status --verbose 2>&1)
	echo "$verbose_status" > "$VERBOSE_CACHE_FILE"
	echo "$verbose_status"
	return 0
}

# get_cached_prefs - Returns cached tailscale debug prefs (5s TTL)
# Returns:
#   JSON output from 'tailscale debug prefs'
get_cached_prefs() {
	if [ -f "$PREFS_CACHE_FILE" ]; then
		local cache_age=$(get_file_age "$PREFS_CACHE_FILE")
		if [ "$cache_age" -lt "$CACHE_TTL" ]; then
			cat "$PREFS_CACHE_FILE"
			return 0
		fi
	fi

	# Cache miss or expired - fetch new prefs
	local prefs=$(/usr/bin/tailscale debug prefs 2>&1)
	echo "$prefs" > "$PREFS_CACHE_FILE"
	echo "$prefs"
	return 0
}

# get_cached_exit_nodes - Returns cached exit nodes list (60s TTL)
# Returns:
#   Newline-separated list of exit nodes in "hostname (IP)" format
# Note:
#   Prefers JSON format (Tailscale 1.38+) for stability, falls back to text parsing
get_cached_exit_nodes() {
	if [ -f "$EXIT_NODES_CACHE_FILE" ]; then
		local cache_age=$(get_file_age "$EXIT_NODES_CACHE_FILE")
		if [ "$cache_age" -lt "$EXIT_NODES_CACHE_TTL" ]; then
			cat "$EXIT_NODES_CACHE_FILE"
			return 0
		fi
	fi

	# Cache miss or expired - fetch new exit nodes list
	local exit_nodes=""

	# Try JSON format first (Tailscale 1.38+) - more stable API
	if /usr/bin/tailscale exit-node list --json >/dev/null 2>&1; then
		exit_nodes=$(/usr/bin/tailscale exit-node list --json 2>&1 | awk '
			BEGIN { RS="},"; FS="[,:]" }
			{
				ip = ""
				hostname = ""
				for (i = 1; i <= NF; i++) {
					if ($i ~ /"ip"/) {
						gsub(/[" ]/, "", $(i+1))
						ip = $(i+1)
					}
					if ($i ~ /"name"/ || $i ~ /"hostname"/) {
						gsub(/[" ]/, "", $(i+1))
						hostname = $(i+1)
						# Extract just the hostname (first part before dot)
						split(hostname, parts, ".")
						hostname = parts[1]
					}
				}
				if (hostname != "" && ip != "") {
					print hostname " (" ip ")"
				}
			}
		')
		logger -t tailscale-luci "Using JSON format for exit node list"
	fi

	# Fallback to text parsing (fragile, but works with older Tailscale versions)
	if [ -z "$exit_nodes" ]; then
		exit_nodes=$(/usr/bin/tailscale exit-node list 2>&1 | awk '
			# Skip header lines, empty lines, and comments
			NR == 1 || /^#/ || /^$/ || /^IP/ || /HOSTNAME/ { next }
			# Process data lines with IP and FQDN
			NF >= 2 && $1 ~ /^[0-9]/ {
				# Extract IP and FQDN
				ip = $1
				fqdn = $2
				# Extract hostname (first part before dot)
				split(fqdn, parts, ".")
				hostname = parts[1]
				# Print in "hostname (IP)" format
				if (hostname != "" && ip != "") {
					print hostname " (" ip ")"
				}
			}
		')
		logger -t tailscale-luci "Using text format for exit node list (JSON not available)"
	fi

	echo "$exit_nodes" > "$EXIT_NODES_CACHE_FILE"
	echo "$exit_nodes"
	return 0
}

# json_extract - Extracts value from JSON using jsonfilter or grep/sed fallback
# Args:
#   $1: json - JSON string to parse
#   $2: path - JSONPath expression (e.g., '$.BackendState')
#   $3: fallback_pattern - Grep pattern to use if jsonfilter unavailable
# Returns:
#   Extracted value or empty string
json_extract() {
	local json="$1"
	local path="$2"
	local fallback_pattern="$3"

	# Try jsonfilter if available
	if command -v jsonfilter >/dev/null 2>&1; then
		echo "$json" | jsonfilter -e "$path" 2>/dev/null && return 0
	fi

	# Fallback to grep/sed
	if [ -n "$fallback_pattern" ]; then
		echo "$json" | grep "$fallback_pattern" | sed 's/.*"[^"]*"[ \t]*:[ \t]*\([^,}]*\).*/\1/' | sed 's/"//g'
	fi
}

case "$1" in
	list)
		json_init
		json_add_object "killswitch"
			json_add_string "action" "string"
		json_close_object
		json_add_object "status"
		json_close_object
		json_add_object "status_verbose"
		json_close_object
		json_add_object "tailscale_info"
		json_close_object
		json_add_object "get_exit_node"
		json_close_object
		json_add_object "set_exit_node"
			json_add_string "node" "string"
		json_close_object
		json_add_object "list_exit_nodes"
		json_close_object
		json_add_object "get_accept_routes"
		json_close_object
		json_add_object "set_accept_routes"
			json_add_string "enabled" "string"
		json_close_object
		json_add_object "get_advertise_routes"
		json_close_object
		json_add_object "set_advertise_routes"
			json_add_string "routes" "string"
		json_close_object
		json_add_object "get_ssh"
		json_close_object
		json_add_object "set_ssh"
			json_add_string "enabled" "string"
		json_close_object
		json_add_object "get_full_status"
		json_close_object
		json_dump
		;;
	call)
		case "$2" in
			killswitch)
				read -r input
				json_load "$input"
				json_get_var action action

				case "$action" in
					enable)
						logger -t tailscale-luci "Enabling killswitch"
						result=$($KILLSWITCH_SCRIPT enable 2>&1)
						;;
					disable)
						logger -t tailscale-luci "Disabling killswitch"
						result=$($KILLSWITCH_SCRIPT disable 2>&1)
						;;
					*)
						result="Invalid action"
						;;
				esac

				json_init
				json_add_string "result" "$result"
				json_dump
				;;
			status)
				# Use structured killswitch status
				ks_state=$(get_killswitch_status)

				# Build descriptive message
				case "$ks_state" in
					enabled)
						result="Killswitch: ENABLED"
						;;
					disabled)
						result="Killswitch: DISABLED"
						;;
					not_installed)
						result="Killswitch: NOT INSTALLED"
						;;
					error)
						result="Killswitch: ERROR"
						;;
					*)
						result="Killswitch: UNKNOWN"
						;;
				esac

				json_init
				json_add_string "result" "$result"
				json_add_string "state" "$ks_state"
				json_dump
				;;
			status_verbose)
				# Use cached verbose status
				result=$(get_cached_verbose_status)

				json_init
				json_add_string "result" "$result"
				json_dump
				;;
			tailscale_info)
				# Get Tailscale version
				ts_version=$(/usr/bin/tailscale version 2>&1 | head -n1)

				# Get cached Tailscale status in JSON format and check BackendState
				ts_status_json=$(get_cached_status)
				backend_state=$(json_extract "$ts_status_json" '$.BackendState' '"BackendState"')

				# BackendState can be: Running, Starting, NeedsLogin, Stopped
				# Connected if Running or Starting
				if [ "$backend_state" = "Running" ] || [ "$backend_state" = "Starting" ]; then
					connected=1
				else
					connected=0
				fi

				json_init
				json_add_boolean "connected" $connected
				json_add_string "version" "$ts_version"
				json_dump
				;;
			get_exit_node)
				# Get cached status
				ts_status_json=$(get_cached_status)

				# Check if exit node is online
				exit_online=$(json_extract "$ts_status_json" '$.ExitNodeStatus.Online' '"Online"')

				if [ "$exit_online" = "true" ]; then
					# Try multiple methods to extract exit node IP (same as get_full_status)
					exit_ip=$(json_extract "$ts_status_json" '$.ExitNodeStatus.TailscaleIPs[0]' '"TailscaleIPs"')

					# Fallback: Look for IP in TailscaleIPs array structure
					# Improved regex to support compressed IPv6 (e.g., ::1, fe80::1)
					if [ -z "$exit_ip" ]; then
						exit_ip=$(echo "$ts_status_json" | grep -o '"TailscaleIPs"[[:space:]]*:[[:space:]]*\[[[:space:]]*"[^"]*"' | sed 's/.*"\([0-9a-fA-F.:]\+\(/[0-9]\+\)\?\)".*/\1/' | head -n1)
					fi

					# Fallback: Extract from ExitNodeStatus block
					# Supports both IPv4 and IPv6 including compressed forms
					if [ -z "$exit_ip" ]; then
						exit_ip=$(echo "$ts_status_json" | sed -n '/ExitNodeStatus/,/^[[:space:]]*}/p' | grep -o '"[0-9a-fA-F.:]\+\(/[0-9]\+\)\?"' | tr -d '"' | head -n1)
					fi

					# Strip CIDR notation if present (e.g., /32 or /128)
					# Tailscale JSON API returns IPs as "100.112.184.50/32" but we need just the IP
					if [ -n "$exit_ip" ]; then
						exit_ip=$(echo "$exit_ip" | sed 's|/[0-9]*$||')
					fi

					# Match against cached exit nodes with anchored grep
					if [ -n "$exit_ip" ]; then
						exit_line=$(get_cached_exit_nodes | grep "($exit_ip)")

						if [ -n "$exit_line" ]; then
							# Cache hit - already formatted
							exit_node="$exit_line"
						else
							# Cache miss - fallback to direct lookup
							direct_line=$(/usr/bin/tailscale exit-node list 2>&1 | awk -v ip="$exit_ip" '$1 == ip { print $0; exit }')
							if [ -n "$direct_line" ]; then
								exit_fqdn=$(echo "$direct_line" | awk '{print $2}')
								exit_hostname=$(echo "$exit_fqdn" | cut -d'.' -f1)
								exit_node="$exit_hostname ($exit_ip)"
							else
								# Last resort: show IP only
								exit_node="$exit_ip"
							fi
						fi
					else
						exit_node=""
					fi
				else
					exit_node=""
				fi

				json_init
				json_add_string "exit_node" "$exit_node"
				json_dump
				;;
			set_exit_node)
				read -r input
				json_load "$input"
				json_get_var node node

				# Invalidate cache before changing settings to prevent race conditions
				invalidate_cache

				if [ -z "$node" ] || [ "$node" = "none" ]; then
					logger -t tailscale-luci "Setting exit node to: none"
					result=$(/usr/bin/tailscale set --exit-node= 2>&1)
					exit_code=$?
					# Wait for Tailscale daemon to update internal state
					sleep 1
				else
					# Validate node format before executing
					if ! validate_node_format "$node"; then
						json_init
						json_add_string "result" "Error: Invalid node format. Expected: 'hostname', 'hostname (IP)', or 'IP address' (e.g., 'router-01', 'router-01 (100.64.0.1)', or '100.64.0.1')."
						json_dump
						exit 0
					fi

					# Extract IP from "hostname (IP)" format if present
					# Frontend sends values like "router-01 (100.64.0.1)"
					# Tailscale CLI needs just the IP or hostname
					actual_node="$node"
					if echo "$node" | grep -q '('; then
						# Extract IP from parentheses
						actual_node=$(echo "$node" | sed 's/.*(\([^)]*\)).*/\1/')
						logger -t tailscale-luci "Extracted IP from format: $actual_node (original: $node)"
					fi

					logger -t tailscale-luci "Setting exit node to: $actual_node"
					result=$(/usr/bin/tailscale set --exit-node="$actual_node" 2>&1)
					exit_code=$?
					# Wait for Tailscale daemon to update internal state
					sleep 1

					# Force immediate cache refresh to prevent stale reads
					if [ $exit_code -eq 0 ]; then
						/usr/bin/tailscale status --json > "$CACHE_FILE" 2>&1
						/usr/bin/tailscale debug prefs > "$PREFS_CACHE_FILE" 2>&1
					fi
				fi

				# Provide helpful error messages
				if [ $exit_code -ne 0 ]; then
					if echo "$result" | grep -q "not found"; then
						result="Error: Exit node not found. Check that the node is online and accessible."
					elif echo "$result" | grep -q "permission denied"; then
						result="Error: Permission denied. Check Tailscale ACL settings."
					elif echo "$result" | grep -q "timeout"; then
						result="Error: Connection timeout. Check network connectivity."
					fi
				fi

				json_init
				json_add_string "result" "$result"
				json_dump
				;;
			list_exit_nodes)
				# Get list of available exit nodes (cached for 60s)
				get_cached_exit_nodes | {
					json_init
					json_add_array "nodes"
					while IFS= read -r node; do
						if [ -n "$node" ]; then
							json_add_string "" "$node"
						fi
					done
					json_close_array
					json_dump
				}
				;;
			get_accept_routes)
				# Get cached status and check if --accept-routes is enabled
				ts_status_json=$(get_cached_status)
				accept_routes=$(json_extract "$ts_status_json" '$.Self.AllowedIPs' '"AcceptRoutes"')

				json_init
				json_add_string "accept_routes" "$accept_routes"
				json_dump
				;;
			set_accept_routes)
				read -r input
				json_load "$input"
				json_get_var enabled enabled

				# Invalidate cache before changing settings to prevent race conditions
				invalidate_cache

				if [ "$enabled" = "true" ] || [ "$enabled" = "1" ]; then
					logger -t tailscale-luci "Setting accept-routes to: true"
					result=$(/usr/bin/tailscale set --accept-routes=true 2>&1)
				else
					logger -t tailscale-luci "Setting accept-routes to: false"
					result=$(/usr/bin/tailscale set --accept-routes=false 2>&1)
				fi
				# Wait for Tailscale daemon to update internal state
				sleep 1

				# Force immediate cache refresh to prevent stale reads
				/usr/bin/tailscale status --json > "$CACHE_FILE" 2>&1
				/usr/bin/tailscale debug prefs > "$PREFS_CACHE_FILE" 2>&1

				json_init
				json_add_string "result" "$result"
				json_dump
				;;
			get_advertise_routes)
				# Get cached status and currently advertised routes
				ts_status_json=$(get_cached_status)
				routes=$(json_extract "$ts_status_json" '$.Self.AdvertiseRoutes' '"AdvertiseRoutes"')

				json_init
				json_add_string "routes" "$routes"
				json_dump
				;;
			set_advertise_routes)
				read -r input
				json_load "$input"
				json_get_var routes routes

				# Invalidate cache before changing settings to prevent race conditions
				invalidate_cache

				if [ -z "$routes" ]; then
					logger -t tailscale-luci "Setting advertise-routes to: none"
					result=$(/usr/bin/tailscale set --advertise-routes= 2>&1)
				else
					# Validate CIDR list format before executing
					if ! validate_cidr_list "$routes"; then
						json_init
						json_add_string "result" "Error: Invalid CIDR format. Use comma-separated list (e.g., 192.168.1.0/24,10.0.0.0/8)"
						json_dump
						exit 0
					fi
					logger -t tailscale-luci "Setting advertise-routes to: $routes"
					result=$(/usr/bin/tailscale set --advertise-routes="$routes" 2>&1)
				fi
				# Wait for Tailscale daemon to update internal state
				sleep 1

				# Force immediate cache refresh to prevent stale reads
				/usr/bin/tailscale status --json > "$CACHE_FILE" 2>&1
				/usr/bin/tailscale debug prefs > "$PREFS_CACHE_FILE" 2>&1

				json_init
				json_add_string "result" "$result"
				json_dump
				;;
			get_ssh)
				# Check if SSH is enabled by checking RunSSH in debug prefs (cached)
				prefs_json=$(get_cached_prefs)

				# Try jsonfilter first, fallback to grep
				run_ssh=$(json_extract "$prefs_json" '$.RunSSH' '"RunSSH"')

				if [ "$run_ssh" = "true" ]; then
					ssh_enabled="true"
				else
					ssh_enabled="false"
				fi

				json_init
				json_add_string "ssh" "$ssh_enabled"
				json_dump
				;;
			set_ssh)
				read -r input
				json_load "$input"
				json_get_var enabled enabled

				# Invalidate cache before changing settings to prevent race conditions
				invalidate_cache

				if [ "$enabled" = "true" ] || [ "$enabled" = "1" ]; then
					logger -t tailscale-luci "Setting SSH to: true"
					result=$(/usr/bin/tailscale set --ssh 2>&1)
				else
					logger -t tailscale-luci "Setting SSH to: false"
					result=$(/usr/bin/tailscale set --ssh=false 2>&1)
				fi
				# Wait for Tailscale daemon to update internal state
				sleep 1

				# Force immediate cache refresh to prevent stale reads
				/usr/bin/tailscale status --json > "$CACHE_FILE" 2>&1
				/usr/bin/tailscale debug prefs > "$PREFS_CACHE_FILE" 2>&1

				json_init
				json_add_string "result" "$result"
				json_dump
				;;
			get_full_status)
				# Consolidated endpoint that returns all status info in one call
				# This reduces multiple RPC calls to just one

				# Get Tailscale version
				ts_version=$(/usr/bin/tailscale version 2>&1 | head -n1)

				# Get cached status
				ts_status_json=$(get_cached_status)

				# Parse BackendState
				backend_state=$(json_extract "$ts_status_json" '$.BackendState' '"BackendState"')
				if [ "$backend_state" = "Running" ] || [ "$backend_state" = "Starting" ]; then
					connected=1
				else
					connected=0
				fi

				# Get exit node info with robust extraction
				exit_online=$(json_extract "$ts_status_json" '$.ExitNodeStatus.Online' '"Online"')

				if [ "$exit_online" = "true" ]; then
					# Try multiple methods to extract exit node IP
					exit_ip=$(json_extract "$ts_status_json" '$.ExitNodeStatus.TailscaleIPs[0]' '"TailscaleIPs"')

					# Fallback: Look for IP in TailscaleIPs array structure
					# Improved regex to support compressed IPv6 (e.g., ::1, fe80::1)
					if [ -z "$exit_ip" ]; then
						exit_ip=$(echo "$ts_status_json" | grep -o '"TailscaleIPs"[[:space:]]*:[[:space:]]*\[[[:space:]]*"[^"]*"' | sed 's/.*"\([0-9a-fA-F.:]\+\(/[0-9]\+\)\?\)".*/\1/' | head -n1)
					fi

					# Fallback: Extract from ExitNodeStatus block
					# Supports both IPv4 and IPv6 including compressed forms
					if [ -z "$exit_ip" ]; then
						exit_ip=$(echo "$ts_status_json" | sed -n '/ExitNodeStatus/,/^[[:space:]]*}/p' | grep -o '"[0-9a-fA-F.:]\+\(/[0-9]\+\)\?"' | tr -d '"' | head -n1)
					fi

					# Strip CIDR notation if present (e.g., /32 or /128)
					# Tailscale JSON API returns IPs as "100.112.184.50/32" but we need just the IP
					if [ -n "$exit_ip" ]; then
						exit_ip=$(echo "$exit_ip" | sed 's|/[0-9]*$||')
					fi

					# Log for debugging
					[ -n "$exit_ip" ] && logger -t tailscale-luci "Found exit IP: $exit_ip"

					# Match against cached exit nodes (anchored search)
					if [ -n "$exit_ip" ]; then
						# Use grep with escaped parentheses for exact match
						exit_line=$(get_cached_exit_nodes | grep "($exit_ip)")

						if [ -n "$exit_line" ]; then
							# Cache hit - use formatted entry
							exit_node="$exit_line"
							logger -t tailscale-luci "Exit node from cache: $exit_node"
						else
							# Cache miss - try direct lookup
							logger -t tailscale-luci "Exit IP not in cache, trying direct lookup"
							direct_line=$(/usr/bin/tailscale exit-node list 2>&1 | awk -v ip="$exit_ip" '$1 == ip { print $0; exit }')

							if [ -n "$direct_line" ]; then
								exit_fqdn=$(echo "$direct_line" | awk '{print $2}')
								exit_hostname=$(echo "$exit_fqdn" | cut -d'.' -f1)
								exit_node="$exit_hostname ($exit_ip)"
								logger -t tailscale-luci "Exit node from direct lookup: $exit_node"
							else
								# Last resort: show IP only
								exit_node="$exit_ip"
								logger -t tailscale-luci "Exit node: IP only: $exit_node"
							fi
						fi
					else
						logger -t tailscale-luci "ERROR: Could not extract exit IP from status JSON"
						exit_node=""
					fi
				else
					exit_node=""
				fi

				# Get route settings
				accept_routes=$(json_extract "$ts_status_json" '$.Self.AllowedIPs' '"AcceptRoutes"')
				advertise_routes=$(json_extract "$ts_status_json" '$.Self.AdvertiseRoutes' '"AdvertiseRoutes"')

				# Get SSH status (cached)
				prefs_json=$(get_cached_prefs)
				run_ssh=$(json_extract "$prefs_json" '$.RunSSH' '"RunSSH"')
				if [ "$run_ssh" = "true" ]; then
					ssh_enabled="true"
				else
					ssh_enabled="false"
				fi

				# Get killswitch status with improved parsing
				ks_state=$(get_killswitch_status)
				case "$ks_state" in
					enabled)
						ks_result="Killswitch: ENABLED"
						;;
					disabled)
						ks_result="Killswitch: DISABLED"
						;;
					not_installed)
						ks_result="Killswitch: NOT INSTALLED"
						;;
					error)
						ks_result="Killswitch: ERROR"
						;;
					*)
						ks_result="Killswitch: UNKNOWN"
						;;
				esac

				# Build consolidated JSON response
				json_init
				json_add_boolean "connected" $connected
				json_add_string "version" "$ts_version"
				json_add_string "exit_node" "$exit_node"
				json_add_string "accept_routes" "$accept_routes"
				json_add_string "advertise_routes" "$advertise_routes"
				json_add_string "ssh" "$ssh_enabled"
				json_add_string "killswitch_status" "$ks_result"
				json_add_string "killswitch_state" "$ks_state"
				json_dump
				;;
		esac
		;;
esac
