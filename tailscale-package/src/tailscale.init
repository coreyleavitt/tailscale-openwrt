#!/bin/sh /etc/rc.common

START=99
STOP=10

USE_PROCD=1

start_service() {
    config_load tailscale

    local enabled
    config_get_bool enabled config enabled 0
    [ "$enabled" -eq 0 ] && return 0

    local port
    config_get port config port 41641

    local log_level
    config_get log_level config log_level ""

    local extra_args
    config_get extra_args config extra_args ""

    # Hardware-detected settings (from postinst)
    local mem_limit gogc no_logs
    config_get mem_limit hardware mem_limit ""
    config_get gogc hardware gogc ""
    config_get_bool no_logs hardware no_logs 0

    # Create directories with appropriate permissions
    mkdir -p /var/run/tailscale
    mkdir -p /etc/tailscale
    chmod 700 /etc/tailscale

    procd_open_instance
    procd_set_param command /usr/sbin/tailscaled
    procd_append_param command --port "$port"
    procd_append_param command --statedir /etc/tailscale
    procd_append_param command --socket /var/run/tailscale/tailscaled.sock

    # Apply no_logs setting
    if [ "$no_logs" -eq 1 ]; then
        procd_append_param command --no-logs-no-support
        procd_set_param stdout 0
        procd_set_param stderr 0
    else
        procd_set_param stdout 1
        procd_set_param stderr 1
    fi

    # Apply memory tuning
    [ -n "$mem_limit" ] && procd_set_param env GOMEMLIMIT="$mem_limit"
    [ -n "$gogc" ] && procd_set_param env GOGC="$gogc"

    [ -n "$log_level" ] && procd_append_param command --verbose="$log_level"

    # Handle extra_args safely (word splitting intentional for multiple args)
    if [ -n "$extra_args" ]; then
        for arg in $extra_args; do
            procd_append_param command "$arg"
        done
    fi

    procd_set_param respawn 3600 5 5
    procd_set_param file /etc/config/tailscale
    procd_close_instance

    # Poke netifd to notice the tailscale0 device after it's created
    # This ensures LuCI shows interface stats even with proto='none'
    ( sleep 3 && ifup tailscale 2>/dev/null ) &

    # Apply killswitch rules if enabled (runs in background after service starts)
    local killswitch
    config_get_bool killswitch config killswitch 0
    if [ "$killswitch" -eq 1 ]; then
        # Delay slightly to ensure tailscaled is starting
        ( sleep 2 && /usr/sbin/tailscale-killswitch apply-rules ) &
    fi

    # Auto-authenticate with authkey on first start
    local authkey
    config_get authkey config authkey ""
    if [ -n "$authkey" ] && [ ! -f /etc/tailscale/tailscaled.state ]; then
        (
            # Wait for tailscaled to be ready
            sleep 3
            for i in 1 2 3 4 5; do
                if /usr/bin/tailscale status >/dev/null 2>&1; then
                    break
                fi
                sleep 1
            done
            # Authenticate with the provided key
            logger -t tailscale "Auto-authenticating with authkey"
            if /usr/bin/tailscale up --authkey="$authkey" --ssh; then
                logger -t tailscale "Authentication successful, clearing authkey from config"
                uci delete tailscale.config.authkey
                uci commit tailscale
            else
                logger -t tailscale "Authentication failed"
            fi
        ) &
    fi
}

reload_service() {
    stop
    start
}

service_stopped() {
    rm -f /var/run/tailscale/tailscaled.sock
}

service_triggers() {
    procd_add_reload_trigger "tailscale"

    # Always watch wan
    procd_add_reload_interface_trigger "wan"

    # Check if wwan interfaces should be watched
    config_load tailscale
    local has_wwan
    config_get_bool has_wwan hardware has_wwan 0
    if [ "$has_wwan" -eq 1 ]; then
        procd_add_reload_interface_trigger "wwan"
        procd_add_reload_interface_trigger "wwan0"
    fi
}
