#!/bin/sh
# Tailscale postinst - configure network, firewall, and hardware optimizations

# Centralized path configuration
TAILSCALE_RUNDIR="/var/run/tailscale"
TAILSCALE_STATEDIR="/etc/tailscale"

# Helper to run uci commands with error logging
uci_safe() {
    if ! uci "$@" 2>/dev/null; then
        logger -t tailscale "postinst: WARNING - uci $* failed"
        return 1
    fi
    return 0
}

# Create state directory with secure permissions (in /etc for persistence across reboots)
mkdir -p "$TAILSCALE_STATEDIR"
chmod 700 "$TAILSCALE_STATEDIR"

# Create runtime directory
mkdir -p "$TAILSCALE_RUNDIR"
chmod 755 "$TAILSCALE_RUNDIR"

# --- Network Interface Setup ---
# Create tailscale interface if it doesn't exist (using named section for easy cleanup)
# Uses proto='none' so netifd observes but doesn't manage the interface.
# This prevents interference with Tailscale's routing table management.
if ! uci -q get network.tailscale >/dev/null; then
    logger -t tailscale "postinst: Creating tailscale network interface"
    uci_safe set network.tailscale=interface
    uci_safe set network.tailscale.proto='none'
    uci_safe set network.tailscale.device='tailscale0'
    uci_safe commit network
fi

# --- Firewall Zone Setup ---
# Create tailscale firewall zone if it doesn't exist (using named section for easy cleanup)
if ! uci -q get firewall.tailscale_zone >/dev/null; then
    logger -t tailscale "postinst: Creating tailscale firewall zone and forwarding rules"

    # Create the zone
    uci_safe set firewall.tailscale_zone=zone
    uci_safe set firewall.tailscale_zone.name='tailscale'
    uci_safe set firewall.tailscale_zone.input='ACCEPT'
    uci_safe set firewall.tailscale_zone.output='ACCEPT'
    uci_safe set firewall.tailscale_zone.forward='REJECT'
    uci_safe set firewall.tailscale_zone.masq='1'
    uci_safe set firewall.tailscale_zone.mtu_fix='1'
    uci_safe set firewall.tailscale_zone.device='tailscale0'

    # LAN -> Tailscale: Allow LAN devices to reach tailnet and use exit node
    uci_safe set firewall.lan_ts_forward=forwarding
    uci_safe set firewall.lan_ts_forward.src='lan'
    uci_safe set firewall.lan_ts_forward.dest='tailscale'

    # Tailscale -> LAN: Allow tailnet to reach LAN (for --exit-node-allow-lan-access)
    uci_safe set firewall.ts_lan_forward=forwarding
    uci_safe set firewall.ts_lan_forward.src='tailscale'
    uci_safe set firewall.ts_lan_forward.dest='lan'

    # Tailscale -> WAN: Required if this router advertises as exit node (disabled by default)
    uci_safe set firewall.ts_wan_forward=forwarding
    uci_safe set firewall.ts_wan_forward.src='tailscale'
    uci_safe set firewall.ts_wan_forward.dest='wan'
    uci_safe set firewall.ts_wan_forward.enabled='0'

    uci_safe commit firewall
fi

# --- Firewall Include for Killswitch ---
# Register killswitch boot script to run at firewall startup (before network)
# This ensures killswitch rules are in place from the first packet
if ! uci -q get firewall.tailscale_killswitch >/dev/null; then
    logger -t tailscale "postinst: Adding killswitch firewall include"
    uci_safe set firewall.tailscale_killswitch=include
    uci_safe set firewall.tailscale_killswitch.type='script'
    uci_safe set firewall.tailscale_killswitch.path='/usr/sbin/tailscale-killswitch-boot'
    uci_safe set firewall.tailscale_killswitch.fw4_compatible='1'
    uci_safe commit firewall
fi

# Reload network and firewall to apply changes
/etc/init.d/network reload 2>/dev/null || true
/etc/init.d/firewall reload 2>/dev/null || true

# --- Hardware Detection ---
# Only auto-detect on first install, preserve user customizations on upgrade
existing_mem_limit=$(uci -q get tailscale.hardware.mem_limit)
existing_gogc=$(uci -q get tailscale.hardware.gogc)

# Skip hardware detection if user has customized settings
if [ -n "$existing_mem_limit" ] || [ -n "$existing_gogc" ]; then
    logger -t tailscale "postinst: Preserving existing hardware settings (mem_limit=$existing_mem_limit, gogc=$existing_gogc)"
else
    # Detect total RAM in MB
    total_ram=$(awk '/MemTotal/ {print int($2/1024)}' /proc/meminfo)

    # Configure based on available RAM
    if [ "$total_ram" -lt 96 ]; then
        # Very low memory (<96MB): aggressive optimization
        uci_safe set tailscale.hardware.mem_limit='50MiB'
        uci_safe set tailscale.hardware.gogc='50'
        uci_safe set tailscale.hardware.no_logs='1'
    elif [ "$total_ram" -lt 192 ]; then
        # Low memory (96-192MB): moderate optimization
        uci_safe set tailscale.hardware.mem_limit='75MiB'
        uci_safe set tailscale.hardware.gogc=''
        uci_safe set tailscale.hardware.no_logs='0'
    else
        # Normal memory (>192MB): no restrictions
        uci_safe set tailscale.hardware.mem_limit=''
        uci_safe set tailscale.hardware.gogc=''
        uci_safe set tailscale.hardware.no_logs='0'
    fi

    logger -t tailscale "postinst: ${total_ram}MB RAM detected, auto-configured hardware settings"
fi

# Detect mobile/LTE interfaces (always update, not user-configurable)
if ls /sys/class/net/ | grep -qE '^(wwan|usb|lte)'; then
    uci_safe set tailscale.hardware.has_wwan='1'
else
    uci_safe set tailscale.hardware.has_wwan='0'
fi

uci_safe commit tailscale

# Log final configuration
logger -t tailscale "postinst: mem_limit=$(uci -q get tailscale.hardware.mem_limit), gogc=$(uci -q get tailscale.hardware.gogc), no_logs=$(uci -q get tailscale.hardware.no_logs), has_wwan=$(uci -q get tailscale.hardware.has_wwan)"

# --- Service Restart on Upgrade ---
# If service was enabled, ensure init symlinks exist and restart
if [ "$(uci -q get tailscale.config.enabled)" = "1" ]; then
    logger -t tailscale "postinst: Service enabled, ensuring init symlinks and restarting"
    /etc/init.d/tailscale enable 2>/dev/null || true
    /etc/init.d/tailscale start 2>/dev/null || true
fi

exit 0
